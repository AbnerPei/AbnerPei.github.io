[{"content":"一、下载Flutter SDK 1. 去Flutter官网下载最新安装包 2. 配置Flutter SDK到指定目录 二、配置Flutter开发环境 【注意】 如果Mac没有安装Homebrew,可通过下面的命令安装：\n1  /usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34;   检查Homebrew版本：\n1 2 3 4 5 6 7  brew --version /* Homebrew 3.2.16 Homebrew/homebrew-core (git revision f7d7160e185; last commit 2021-10-12) Homebrew/homebrew-cask (git revision d101c8d60c; last commit 2021-10-12) */   2.1、进入用户home目录 1  cd ~/   2.2、打开.bash_profile并编辑 1  open .bash_profile   在.bash_profile中添加：\n1 2 3 4 5  # Flutter export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn export PATH=/Users/peijianbo/Documents/Flutter/flutter/bin:$PATH # Flutter END    【提醒】 其中/Users/klcw/peijianbo/Flutter/flutter是我自己电脑对应的Flutter SDK的目录，你需要修改为你的Flutter SDK对应的目录。\n【注意】 除了export后有个空格，其它地方不要有空格。\n 2.3、command + s保存修改并关闭.bash_profile 2.4、令修改后的配置生效 1  source .bash_profile   2.5、检查Flutter开发环境是否可用 1  flutter doctor   出现如上图的终端，就说明Flutter的开发环境配置成功了。\n","date":"2022-04-09T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2022/20220409.jpeg","permalink":"https://example.com/p/flutter-config/","title":"Mac上Flutter开发环境配置"},{"content":"周末在家，天公不做美，大雨！所以，就优化一下之前的一个开源库PPMaker，可是在提交的时候，就遇到了如下的问题：\n不过，庆幸的是，刚好在我搜这个问题2小时前，有人给出了解决方案：\n 【GitHub不再支持密码验证解决方案：SSH免密与Token登录配置】\n 文中给出了3种方案，我选择了第3种：\n第①步：前往GitHub，复制SSH的url\n第②步：找到PPMaker本地目录下的config文件\n第③步：把HTTPS的url替换成SSH的url\n最后，成功了\n","date":"2022-04-08T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2022/20220408.jpeg","permalink":"https://example.com/p/git-error-20210813/","title":"git报错：remote/ Support for password authentication was removed on August 13, 2021的解决办法"},{"content":"截止目前（2021-10-16）为止，要想实现下面的几种button样式（这里要考虑图片和文字间距），我所知道的方案有两种：\n  给UIButton添加分类\n  自定义UIButton\n  而在实际开发中，我们使用 方案1 应该是最多的！\n自我参加工作（2015-06）以来，对于UIButton如上图的需求就一直有，而且还有很多！说实话，我也一直困惑，苹果爸爸问什么不支持一下呢？\n也许是有人不停地给苹果爸爸提issue， 也许是苹果爸爸也遇到大量的如此需求， 也许苹果爸爸做了统计发现几乎所有APP都有UIButton这类Categroy（Swift是Extension）, 也许苹果爸爸终于闲了有时间管了， 也许\u0026hellip;， 不管怎么说，iOS15，苹果爸爸支持了！而且API也如预期的那样简单：\n1 2 3 4 5 6  var conf = UIButton.Configuration.borderedTinted() /// 设置图片的摆放（图片在上，则文字在下） conf.imagePlacement = .top /// 设置图片和文字的间距 conf.imagePadding = 10 let bt = UIButton.init(configuration: conf, primaryAction: nil)    插一句：对于configuration这样的API设计，我是非常认可的，一看就知道是干什么用的！感觉苹果爸爸也有意如此设计，比如iOS14开始的的PHPickerConfiguration等。\n 而我能发现这个，源自今天（2021-10-16）下午，打算用Swift重写老项目（《酷乐潮玩》）的一个推荐列表页，其中cell上有如下几个按钮，我想参考OC写的UIButton的category，也写个Swift版的：\n可是，在敲titleedg时，竟提示'titleEdgeInsets' will be deprecated in iOS 15.0。这瞬间激起了我的兴趣，于是点击进去一探究竟！\nSwift版UIButtonConfiguration： Objective-C版UIButtonConfiguration： 于是，我粗略地写了个demo验证一下，最终效果图：\n具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. view.backgroundColor = .white test() } func test() { var conf1 = UIButton.Configuration.plain() conf1.title = \u0026#34;点赞\u0026#34; conf1.image = UIImage(named: \u0026#34;liked\u0026#34;) conf1.imagePlacement = .leading conf1.imagePadding = 10 let bt1 = UIButton.init(configuration: conf1, primaryAction: nil) var conf2 = UIButton.Configuration.bordered() conf2.title = \u0026#34;点赞\u0026#34; conf2.image = UIImage(named: \u0026#34;liked\u0026#34;) conf2.imagePlacement = .trailing conf2.imagePadding = 40 let bt2 = UIButton.init(configuration: conf2, primaryAction: nil) var conf3 = UIButton.Configuration.borderedTinted() conf3.title = \u0026#34;点赞\u0026#34; conf3.image = UIImage(named: \u0026#34;liked\u0026#34;) conf3.imagePlacement = .top conf3.imagePadding = 10 let bt3 = UIButton.init(configuration: conf3, primaryAction: nil) var conf4 = UIButton.Configuration.gray() conf4.title = \u0026#34;点赞\u0026#34; conf4.image = UIImage(named: \u0026#34;liked\u0026#34;) conf4.imagePlacement = .bottom conf4.imagePadding = 10 let bt4 = UIButton.init(configuration: conf4, primaryAction: nil) bt1.frame = CGRect(x: 50, y: 100, width: 100, height: 80) bt2.frame = CGRect(x: 200, y: 100, width: 150, height: 80) bt3.frame = CGRect(x: 50, y: 230, width: 100, height: 80) bt4.frame = CGRect(x: 200, y: 230, width: 100, height: 80) view.addSubview(bt1) view.addSubview(bt2) view.addSubview(bt3) view.addSubview(bt4) } }   最后，话又说回来了，目前我们的APP不可能是从iOS15开始的，估计大多数是从iOS11开始的，还有一部分是从iOS9开始，也有一部分是从iOS13开始的，所以 做好兼容还是很有必要的！\n而更多关于UIButton的新知，请自行查看API学习，总体感觉：UIButton更丰富多彩了！\n","date":"2021-10-16T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2021/20211016.jpeg","permalink":"https://example.com/p/ios-ios15-uibutton-update-api/","title":"iOS15终于迎来了UIButton的这个改动！"},{"content":"PPMaker是什么❓ 声明：PPMaker跟Masonry功能上是完全不同的库，PPMaker是快速便捷创建UI/attributedText等的，而Masonry是布局的。\n 做iOS开发，创建UI控件，必须的不说，还多，尤其你新入手一个项目。\n我自己写代码，向来想省事：怎么能不一个一个属性写？ 带着这个问题，我刚开始创建了各种Tool来处理，后来用Category，可Category有个烦人的问题：有些属性我不需要但是方法参数有，而有些属性我需要方法参数没有。\n昨天，看到臧成威的如何利用Objective-C写一个精美的DSL，挺好，就想着优化下自己的代码，于是就有了 PPMaker.\n在此，献上对臧老师的感谢。\n PPMaker的不同（优点） ①、链式调用，代码简洁\n②、点语法后面有提示（Masonry是没有的 ）\n③、不需要终结词，臧老师给的示例有\n④、不需要助词 （如Masonry中的with），这个也可以说是一个缺点吧\n⑤、pod可根据需求随意选择\n⑥、不需要的属性，根本不用管 主要对比Category\nPPMaker的用法 第一步、导入PPMaker\n 方法一、使用CocoaPods安装  1  pod \u0026#39;PPMaker\u0026#39;, \u0026#39;~\u0026gt; 0.0.22\u0026#39;    方法二、手动下载拖入  第二步、用对应的类（如:UILable）直接调用pp_\n使用示例：创建一个简单的UILabel对象\n maker调用，直接调UILabel对象的属性，如text、textColor、frame等，当然也有自定义的，如intoView表示要加到哪个view上、fontSize实际上[UIFont systemFontOfSize:fontSize]的简化等等。\n总之，PPMaker is very easy to use。\n 回顾：创建UI控件的路程 起初：一个属性一个属性赋值 1 2 3 4 5 6 7  UILabel *lb = [[UILabel alloc]initWithFrame:CGRectMake(10, 10, 300, 50)]; [self.view addSubview:lb]; lb.backgroundColor = [UIColor whiteColor]; lb.text = @\u0026#34;我是一个lb\u0026#34;; lb.textColor = [UIColor blueColor]; lb.textAlignment = NSTextAlignmentCenter; lb.font = [UIFont systemFontOfSize:18];  \n后来：用Category快速创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  @interface UILabel (EasyMake) +(UILabel *)lbMakeWithSuperV:(UIView *)superV frame:(CGRect)frame font:(UIFont *)font alignment:(NSTextAlignment)alignment text:(NSString *)text textColor:(UIColor *)textColor; @implementation UILabel (EasyMake) +(UILabel *)lbMakeWithSuperV:(UIView *)superV frame:(CGRect)frame font:(UIFont *)font alignment:(NSTextAlignment)alignment text:(NSString *)text textColor:(UIColor *)textColor { UILabel *lb = [[UILabel alloc]init]; if (superV) { [superV addSubview:lb]; } if (font) { lb.font = font; } if (text) { lb.text = text; } if (textColor) { lb.textColor = textColor; } lb.frame = frame; lb.textAlignment = alignment; return lb; } @end   现在：链式调用的DSL\n结语 PPMaker是自己写的最满意的一个库之一，解决了自己一直以来创建UI、配置attributedText 的苦恼，这其中也参考了一些大神的的blog和开源库，在此，表示感谢。今天，分享自己的这个库，希望帮助像我一样的同学，其次，希望觉得好的，给个star。\n当然了，这个库，我会持续更新的，有什么问题，欢迎提出来。或者谁有更好的做法，热烈欢迎告知一下，深表谢意！\n","date":"2018-05-09T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2018/20180509.jpeg","permalink":"https://example.com/p/ios%E9%93%BE%E5%BC%8F%E5%88%9B%E5%BB%BAui%E7%BB%88%E7%BB%93%E8%80%85-ppmaker/","title":"iOS链式创建UI终结者 ➜ PPMaker"},{"content":"一、前言  最近在解答[最新版]MJRefresh解析与详细使用指导和MJRefresh实现刷新（使用它的Block方法）中简友的提问，浅读了下 MJRefresh 的源码 (关于源码解读，网上已有很多，我后续也会写一篇我自己的解读，不过今天要说的是：借鉴别人的思路，做or完善自己的事。):\n利用KVO在- (void)willMoveToSuperview:(UIView *)newSuperview方法调用时监听scrollView的contentOffset/contentSize和panGestureRecognizer的state属性，然后做对应操作。\n 二、开发困惑 通常，作为iOS开发人员，判断UIScrollView/UITableView/UICollectionView的滚动情况的事，时有发生。如果每次都去实现delegate方法，在我看来，有些麻烦。除了一遍一遍的写代理，还有一种就是建个基类，但是这样基类还是要实现对应的delegate方法。\n三、解决方法：给UIScrollView添加block属性监听滚动  先预览下效果(上面红色的是手机录屏所致)：  四、理清思路   新建一个类 PPMJRefreshComponent,类似MJRefresh中的MJRefreshComponent，用来当做观察者; 既然 PPMJRefreshComponent 要观察 UIScrollView 的contentOffset以及panGestureRecognizer的state,那么 PPMJRefreshComponent 就要关联当前的 UIScrollView；并且，UIScrollView 要拥有一个 PPMJRefreshComponent 对象（如下图：）；    PPMJRefreshComponent 观察的结果怎么传递给 UIScrollView？我采用的是delegate(PPMJRefreshComponentDelegate),需要 UIScrollView 对象遵守；（此处不使用block是因为block嵌套block容易出问题）    UIScrollView 对象实现代理，并设置scrollBlock的时候触发监听：(代码如下，注释已写进去)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  @implementation UIScrollView (ScrollBlock) #pragma mark --- PPMJRefreshComponentDelegate -(void)scrollViewContentOffsetDidChange:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change{ [self contentOffsetBlockAction:change]; } -(void)scrollViewPanStateDidChange:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change{ [self panGestureRecognizerStateAction:change]; } -(void)contentOffsetBlockAction:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change { //这个属性字面理解意思为：正在拖动。实际上是：scrollView是否滚动了，只要不是最开始初始化的时候设置的位置，就为YES。  if (!self.isDragging) { return; } //【注意】此处要特别注意，如果设置contentInset的话，要给pp_lastContentOffsetY赋值为insetT的初始值  if (!self.pp_lastContentOffsetY) { [self setupInitializeOffsetY]; } //获取当前的contentOffsetY  CGFloat currentContentOffsetY = self.pp_FSB_offsetY; //如果前后的contentOffsetY值相同，就不做处理  CGFloat lastContentOffsetY = [self.pp_lastContentOffsetY floatValue]; if (currentContentOffsetY == lastContentOffsetY) { return; } //是否是向上滑，初始值为NO  BOOL isToUp = NO; //向上滑动  if (currentContentOffsetY \u0026gt; lastContentOffsetY) { //处理滑动到底部，继续上滑后系统自动反弹而重复调用的情况  if (currentContentOffsetY+self.pp_h \u0026gt; self.pp_FSB_contentH) { return; } isToUp = YES; }else{ //向下滑动  //处理已经最上面了仍然下拉而反弹时，反复调用  if (currentContentOffsetY \u0026lt;= self.pp_FSB_insetT) { return; } } //给pp_lastContentOffsetY绑定值  objc_setAssociatedObject(self, @selector(pp_lastContentOffsetY), [NSNumber numberWithFloat:currentContentOffsetY], OBJC_ASSOCIATION_RETAIN); //是否超过一个屏幕  BOOL isInOneScreen = (self.pp_FSB_insetT+self.pp_FSB_contentH \u0026lt;= self.pp_h); if (self.pp_scrollBlock) { self.pp_scrollBlock(currentContentOffsetY, isToUp,isInOneScreen); } } -(void)panGestureRecognizerStateAction:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change { if (self.panGestureRecognizer.state == UIGestureRecognizerStateEnded) { //内容不够一个屏幕时，系统会自动回弹，这时候记得把pp_lastContentOffsetY重新设置一下  if (self.pp_FSB_insetT+self.pp_FSB_contentH \u0026lt;= self.pp_h) { [self setupInitializeOffsetY]; }else{ //超过一个屏幕,这时候下拉，当松开的时候要把pp_lastContentOffsetY重新设置一下  if (self.pp_FSB_offsetY \u0026lt; self.pp_FSB_insetT) { [self setupInitializeOffsetY]; } } } } #pragma mark --- 初始化contentOffsetY的值 -(void)setupInitializeOffsetY{ CGFloat currentContentOffsetY = -self.pp_FSB_insetT; objc_setAssociatedObject(self, @selector(pp_lastContentOffsetY), [NSNumber numberWithFloat:currentContentOffsetY], OBJC_ASSOCIATION_RETAIN); } -(void)setPp_scrollBlock:(PPUIScrollViewScrollBlock)pp_scrollBlock { //在设置scrollBlock的时候，触发监听  self.pp_component.delegate = self; objc_setAssociatedObject(self, @selector(pp_scrollBlock), pp_scrollBlock, OBJC_ASSOCIATION_RETAIN); } -(PPUIScrollViewScrollBlock)pp_scrollBlock { return objc_getAssociatedObject(self, _cmd); } @end   针对上面的代码补充说明如下：\n 注意 component 的初识与关联，一定要弄懂为啥我代码中要用runtime强制关联; 注意 pp_lastContentOffsetY 的使用，它是给 UIScrollView 动态绑定的记录上一次的contentOffsetY值的，只有在滑动的时候有效，最终如果你放外部的话，偏移量还是和contentOffset.Y的值一样。 -(void)contentOffsetBlockAction:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change这个方法处理滑动情况，但是 开始下拉 和 上拉到底 的两种临街状态时的 pp_lastContentOffsetY 需要特殊处理，而这个处理就放在panGestureRecognizer.state == UIGestureRecognizerStateEnded的时候。  最后，感谢 MJRefresh！\n 2018-03-08 14:20:40 妇女节快乐！ 感谢公司的 party,此刻 吃着零食喝着饮料，匆匆结文。\n ","date":"2018-03-08T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2018/20180308.jpeg","permalink":"https://example.com/p/ugc-20180308/","title":"浅读MJRefresh后自定义了个UIScrollView监听滚动的block属性"},{"content":" [赠语]：Anything you\u0026rsquo;re good at contributes to happiness.\n 一、 NSCharacterSet是什么❓ 1.1 先来看下面的例子：\n 需求： 有一个字符串: @\u0026ldquo;今天我们来学习NSCharacterSet我们快乐\u0026rdquo;，去除字符串中所有的 @\u0026ldquo;今\u0026rdquo;、@\u0026ldquo;我\u0026rdquo;、@\u0026ldquo;s\u0026rdquo;。 【注意】s是小写\n  思考：如果是你怎么解决？\n 自己写。 用 NSCharacterSet。   1.1.1 自己写,如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14  NSString *str = @\u0026#34;今天我们来学习NSCharacterSet我们快乐\u0026#34;; NSString *str1 = @\u0026#34;我s今\u0026#34;; NSMutableString *resultStr = [[NSMutableString alloc]init]; for (int i = 0; i \u0026lt; str.length; i++) { NSString *indexStr = [str substringWithRange:NSMakeRange(i, 1)]; if (![str1 containsString:indexStr]) { [resultStr appendString:indexStr]; } } NSLog(@\u0026#34;自己写---%@\u0026#34;,resultStr); //2016-12-23 13:19:42.584 PPDemos[9065:6978391] 自己写---天们来学习NSCharacterSet们快乐    1.1.2 用NSCharacterSet,如下： 1 2 3 4 5  NSString *str = @\u0026#34;今天我们来学习NSCharacterSet我们快乐\u0026#34;; NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@\u0026#34;我s今\u0026#34;]; NSArray *setArr = [str componentsSeparatedByCharactersInSet:characterSet]; NSString *resultStr1 = [setArr componentsJoinedByString:@\u0026#34;\u0026#34;]; NSLog(@\u0026#34;拆分后的字符串数组------%@\\n最终字符串------%@\u0026#34;,setArr,resultStr1);     总结： 至此，通过上面的两个方法，已经解决了需求的问题。通过自己写，结合用NSCharacterSet，可以推断出NSCharacterSet类似一个 字符串处理工具类，而事实上，由名字也可以看出，它确实是！\n 二、 NSCharacterSet的常用API学习 1 2 3 4  /** 001 根据一个给定的字符串获取一个NSCharacterSet对象 */ + (NSCharacterSet *)characterSetWithCharactersInString:(NSString *)aString; // 使用实例，如上例！！   1 2  /** 002 相反字符串限制 【具体见接下的例子】 */ @property (readonly, copy) NSCharacterSet *invertedSet;   1 2 3 4 5 6 7 8 9 10 11 12  /** 003 常用快捷方法集合 （常用的，已满足大多数需求） */ + controlCharacterSet + whitespaceCharacterSet //空格  + whitespaceAndNewlineCharacterSet //空格和换行符  + decimalDigitCharacterSet //0-9的数字  + letterCharacterSet //所有字母  + lowercaseLetterCharacterSet //小写字母  + uppercaseLetterCharacterSet //大写字母  + alphanumericCharacterSet //所有数字和字母（大小写不分）  + punctuationCharacterSet //标点符号  + newlineCharacterSet //换行    002 的 例子 1 2 3 4 5 6 7 8  NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@\u0026#34;0123456789\u0026#34;]; NSString *str = @\u0026#34;7sjf78sf990s\u0026#34;; NSLog(@\u0026#34;set----%@\u0026#34;,[str componentsSeparatedByCharactersInSet:set]); NSCharacterSet *invertedSet = [[NSCharacterSet characterSetWithCharactersInString:@\u0026#34;0123456789\u0026#34;] invertedSet]; NSLog(@\u0026#34;invertedSet----%@\u0026#34;,[str componentsSeparatedByCharactersInSet:invertedSet]); //打印结果如下图： 【可以看出invertedSet后，刚好判断条件相反】    明白了001和002，下面有个需求，该怎么实现？自己想吧！\n  需求：textFielf只能输入数字\n 三、 NSMutableCharacterSet的常用API学习  NSCharacterSet的，NSMutableCharacterSet都可以用。【这句貌似有些多余】。\n 1 2 3  /** 工能同 invertedSet 方法一样，注意这个没有返回值 */ - (void)invert;    附 textFielf只能输入数字的答案,如下:\n 1 2 3 4 5 6 7 8  - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { NSCharacterSet *charSet = [[NSCharacterSet characterSetWithCharactersInString:@\u0026#34;0123456789\u0026#34;] invertedSet]; NSString *filteredStr = [[string componentsSeparatedByCharactersInSet:charSet] componentsJoinedByString:@\u0026#34;\u0026#34;]; if ([string isEqualToString:filteredStr]) { return YES; } return NO; }   ","date":"2016-12-23T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2016/20161213.jpeg","permalink":"https://example.com/p/%E5%AD%A6%E4%BC%9Anscharacterset%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","title":"学会NSCharacterSet，再也不怕各种字符串处理！"}]